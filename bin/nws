#!/usr/bin/env bash

# --- STANDARD SCRIPT-GLOBAL CONSTANTS

kTHIS_NAME=${BASH_SOURCE##*/}
kTHIS_HOMEPAGE='https://github.com/mklement0/nws-cli'
kTHIS_VERSION='v0.2.0' # NOTE: This assignment is automatically updated by `make version VER=<newVer>` - DO keep the 'v' prefix.

unset CDPATH  # To prevent unexpected `cd` behavior.

# --- Begin: STANDARD HELPER FUNCTIONS

die() { echo "$kTHIS_NAME: ERROR: ${1:-"ABORTING due to unexpected error."}" 1>&2; exit ${2:-1}; }
dieSyntax() { echo "$kTHIS_NAME: ARGUMENT ERROR: ${1:-"Invalid argument(s) specified."} Use -h for help." 1>&2; exit 2; }

# SYNOPSIS
#   openUrl <url>
# DESCRIPTION
#   Opens the specified URL in the system's default browser.
openUrl() {
  local url=$1 platform=$(uname) cmd=()
  case $platform in
    'Darwin') # OSX
      cmd=( open "$url" )
      ;;
    'CYGWIN_'*) # Cygwin on Windows; must call cmd.exe with its `start` builtin
      cmd=( cmd.exe /c start '' "$url " )  # !! Note the required trailing space.
      ;;
    'MINGW32_'*) # MSYS or Git Bash on Windows; they come with a Unix `start` binary
      cmd=( start '' "$url" )
      ;;
    *) # Otherwise, assume a Freedesktop-compliant OS, which includes many Linux distros, PC-BSD, OpenSolaris, ...
      cmd=( xdg-open "$url" )
      ;; 
  esac
  "${cmd[@]}" || { echo "Cannot locate or failed to open default browser; please go to '$url' manually." >&2; return 1; }
}

# Prints the embedded Markdown-formatted man-page source to stdout.
printManPageSource() {
  sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/ { s///; t\np;}' "$BASH_SOURCE"
}

# Opens the man page, if installed; otherwise, tries to display the embedded Markdown-formatted man-page source; if all else fails: tries to display the man page online.
openManPage() {
  local pager embeddedText 
  if ! man 1 "$kTHIS_NAME" 2>/dev/null; then
    # 2nd attempt: if present, display the embedded Markdown-formatted man-page source
    embeddedText=$(printManPageSource)
    if [[ -n $embeddedText ]]; then
      pager='more'
      command -v less &>/dev/null && pager='less' # see if the non-standard `less` is available, because it's preferable to the POSIX utility `more`
      printf '%s\n' "$embeddedText" | "$pager"
    else # 3rd attempt: open the the man page on the utility's website
      openUrl "${kTHIS_HOMEPAGE}/doc/${kTHIS_NAME}.md"
    fi
  fi  
}

# Prints the contents of the synopsis chapter of the embedded Markdown-formatted man-page source for quick reference.
printUsage() {
  local embeddedText
  # Extract usage information from the SYNOPSIS chapter of the embedded Markdown-formatted man-page source.
  embeddedText=$(sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/!d; /^## SYNOPSIS$/,/^#/{ s///; t\np; }' "$BASH_SOURCE")
  if [[ -n $embeddedText ]]; then
    # Print extracted synopsis chapter - remove backticks for uncluttered display.
    printf '%s\n\n' "$embeddedText" | tr -d '`'
  else # No SYNOPIS chapter found; fall back to displaying the man page.
    echo "WARNING: usage information not found; opening man page instead." >&2
    openManPage
  fi
}

# --- End: STANDARD HELPER FUNCTIONS

# ---  PROCESS STANDARD, OUTPUT-INFO-THEN-EXIT OPTIONS.
case $1 in
  --version)
    # Output version number and exit, if requested.
    echo "$kTHIS_NAME $kTHIS_VERSION"$'\nFor license information and more, visit '"$kTHIS_HOMEPAGE"; exit 0
    ;;
  -h|--help)
    # Print usage information and exit.
    printUsage; exit
    ;;
  --man)
    # Display the manual page and exit, falling back to printing the embedded man-page source.
    openManPage; exit
    ;;
  --man-source) # private option, used by `make update-man`
    # Print raw, embedded Markdown-formatted man-page source and exit
    printManPageSource; exit
    ;;
  --home)
    # Open the home page and exit.
    openUrl "$kTHIS_HOMEPAGE"; exit
    ;;
esac

# --- BEGIN: functions

# Helper function for exiting with error message due to runtime error.
#   die [errMsg [exitCode]]
# Default error message states context and indicates that execution is aborted. Default exit code is 1.
# Prefix for context is always prepended.
# Note: An error message is *always* printed; if you just want to exit with a specific code silently, use `exit n` directly.
die() {
  echo "$kTHIS_NAME: ERROR: ${1:-"ABORTING due to unexpected error."}" 1>&2
  exit ${2:-1} # Note: If the argument is non-numeric, the shell prints a warning and uses exit code 255.
}

# Helper function for exiting with error message due to invalid arguments.
#   dieSyntax [errMsg]
# Default error message is provided, as is prefix and suffix; exit code is always 2.
dieSyntax() {
  echo "$kTHIS_NAME: ARGUMENT ERROR: ${1:-"Invalid argument(s) specified."} Use -h for help." 1>&2
  exit 2
}

# SYNOPSIS
#   normalizeWhiteSpace [mode]
# DESCRIPTION
#   Normalizes whitespace in the input provided via stdin, using one of 4 modes:
#   All modes behave identically with respect to normalizing individual lines:
#     Any run of any mix of spaces and tabs is replaced with a single space each, except leading and trailing runs, which are discarded.
#   Thus, specifying a mode applies only to *multi-line* input (all modes behave the same with single-line input):
#   0 (default) ... runs of blank (all-whitespace or empty) lines are replaced with 1 empty line each, resulting in paragraph-internal newlines getting preserved, with blank lines at the beginning, between paragraphs, and at the end getting normalized to a single empty line each.
#   1 ... runs of blank (all-whitespace or empty) lines are discarded, resulting in a single block of non-blank lines.
#   2 ... like mode 0, except that paragraph-internal newlines are replaced with a single space each, resulting in each paragraph becoming a single line, with 1 empty line between paragraphs.
#   3 ... normalization includes newlines too, so that any run of any mix of spaces, tabs, and newlines is replaced with a single space each, resulting in a single, long output line.
# EXAMPLES
#   normalizeWhiteSpace <<<$' a   b  \t \t'  # -> 'a b'
#   normalizeWhiteSpace 0 <<<$'\n \n line\t1\n  line  2 \n\nline 3\n\n\n'  # -> $'\nline 1\nline 2\n\nline 3' (0 is optional)
#   normalizeWhiteSpace 1 <<<$'\n \n line\t1\n  line  2 \n\nline 3\n\n\n'  # -> $'line 1\nline 2\nline 3'
#   normalizeWhiteSpace 2 <<<$'\n \n line\t1\n  line  2 \n\nline 3\n\n\n'  # -> $'\nline 1 line 2\n\nline 3'
#   normalizeWhiteSpace 3 <<<$'\n \n line\t1\n  line  2 \n\nline 3\n\n\n'  # -> $'line 1 line 2 line 3'
normalizeWhiteSpace() {
  case $1 in
    0|'') # default: line-interior normalization with leading and trailing runs discarded; runs of blank (all-whitespace or empty) lines replaced with 1 empty line each -> multiple paragraphs with 1 empty line in between
      awk '{$1=$1; print}' | cat -s # rebuild the line with a space between fields (may result in empty lines), then replace each run of empty lines with a single empty line.
      ;;
    1) # line-interior normalization with leading and trailing runs discarded; runs of blank (all-whitespace or empty) lines discarded -> 1 block of non-empty lines
      awk '{$1=$1} $1!=""' # rebuild the line with a space between fields; if there's at least 1 field, print the rebuilt line.
      ;;
    2) # paragraph-interior normalization (across non-empty lines), runs of blank (all-whitespace or empty) lines replaced with 1 empty line each -> each paragraph becomes 1 long line with 1 empty line in between
      awk '{$1=$1; nonEmpty=($1!=""); printf ((nonEmpty && prevNonEmpty) ? " " : ((NR > 1) ? "\n" : "")); prevNonEmpty=nonEmpty; printf "%s", $0} END { printf "\n" }' | cat -s # rebuild the line with a space between fields (may result in empty lines), then replace each run of empty lines with a single empty line.
      ;;
    3) # normalization across *all* types of whitespace, including newlines -> 1 long line
      awk 'r!="" { printf "%s%s", sep, r; r=""; sep=" " } { $1=$1; if ($1!="") r=$0 } END { if (r!="") printf "%s%s", sep, r }' 
      printf '\n'
      ;;
    *)
      echo "Unknown normalization mode: '$1'." >&2; return 2
      ;;
  esac
}

# --- END: functions

# --- MAIN BODY

# ----- BEGIN: OPTIONS PARSING: This is MOSTLY generic code, but:
#  - SET allowOptsAfterOperands AFTER THIS COMMENT TO 1 to ALLOW OPTIONS TO BE MIXED WITH OPERANDS rather than requiring all options to come before the 1st operand, as POSIX mandates.
#  - The SPECIFIC OPTIONS MUST BE HANDLED IN A CASE ... ESAC STATEMENT BELOW; look for "BEGIN: CUSTOMIZE HERE ... END: CUSTOMIZE HERE"
#  - Assumes presence of function dieSyntax(); if not present, define as: dieSyntax() { echo "$(basename -- "$BASH_SOURCE"): ARGUMENT ERROR: ${1:-"Invalid argument(s) specified."} Use -h for help." >&2; exit 2; }
#  - After the end of options parsing, $@ only contains the operands (non-option arguments), if any.
allowOptsAfterOperands=1 operands=() i=0 optName= isLong=0 prefix= optArg= haveOptArgAttached=0 haveOptArgAsNextArg=0 acceptOptArg=0 needOptArg=0 optsSpecified=0
while (( $# )); do
  if [[ $1 =~ ^(-)[a-zA-Z0-9]+.*$ || $1 =~ ^(--)[a-zA-Z0-9]+.*$ ]]; then # an option: either a short option / multiple short options in compressed form or a long option
    prefix=${BASH_REMATCH[1]}; [[ $prefix == '--' ]] && isLong=1 || isLong=0
    for (( i = 1; i < (isLong ? 2 : ${#1}); i++ )); do
        acceptOptArg=0 needOptArg=0 haveOptArgAttached=0 haveOptArgAsNextArg=0 optArgAttached= optArgOpt= optArgReq=
        if (( isLong )); then # long option: parse into name and, if present, argument
          optName=${1:2}
          [[ $optName =~ ^([^=]+)=(.*)$ ]] && { optName=${BASH_REMATCH[1]}; optArgAttached=${BASH_REMATCH[2]}; haveOptArgAttached=1; }
        else # short option: *if* it takes an argument, the rest of the string, if any, is by definition the argument.
          optName=${1:i:1}; optArgAttached=${1:i+1}; (( ${#optArgAttached} >= 1 )) && haveOptArgAttached=1
        fi
        (( haveOptArgAttached )) && optArgOpt=$optArgAttached optArgReq=$optArgAttached || { (( $# > 1 )) && { optArgReq=$2; haveOptArgAsNextArg=1; }; }
        optsSpecified=1
        # ---- BEGIN: CUSTOMIZE HERE
        nwsMode= handled=0
        case $optName in
          m|mode)
            needOptArg=1
            nwsMode=$optArgReq
            ;;
          *)  # We also accept the mode as direct options, so that --mode fp is identical to --fp
            nwsMode=$optName
            ;;
        esac
        if [[ -n $nwsMode ]]; then
          handled=1
          case $nwsMode in
            0|1|2|3) # !! We still accept the numerical modes, but they're deprecated and no longer documented.
              :
              ;;
            mp|multi-para)
              nwsMode=0
              ;;
            sp|single-para)
              nwsMode=1
              ;;
            fp|flat-para)
              nwsMode=2
              ;;
            sl|single-line)
              nwsMode=3
              ;;              
            *)
              (( needOptArg )) && dieSyntax "Unknown mode specified: '$nwsMode'."
              handled=0
              ;;
          esac
        fi
        if (( ! handled )); then
          case $optName in
            *)            
              dieSyntax "Unknown option: ${prefix}${optName}."
              ;;
          esac
        fi
        # ---- END: CUSTOMIZE HERE
        (( needOptArg )) && { (( ! haveOptArgAttached && ! haveOptArgAsNextArg )) && dieSyntax "Option ${prefix}${optName} is missing its argument." || (( haveOptArgAsNextArg )) && shift; }
        (( acceptOptArg || needOptArg )) && break
    done
  else # an operand
    if [[ $1 == '--' ]]; then
      shift; operands+=( "$@" ); break
    elif (( allowOptsAfterOperands )); then
      operands+=( "$1" ) # continue 
    else
      operands=( "$@" )
      break
    fi
  fi
  shift
done
(( "${#operands[@]}" > 0 )) && set -- "${operands[@]}"; unset allowOptsAfterOperands operands i optName isLong prefix optArgAttached haveOptArgAttached haveOptArgAsNextArg acceptOptArg needOptArg
# ----- END: OPTIONS PARSING: "$@" now contains all operands (non-option arguments).

# Gather the input: remaining operand(s) OR stdin:
if (( $# )); then
  txt=$*
else # read from stdin    
  IFS= read -rd $'\x04' txt # !! The $'\x04' is required to support ^D to terminate *interactive* input.
fi

# Do nothing, if the input is empty.
(( ${#txt} > 0 )) || exit 0

normalizeWhiteSpace $nwsMode < <(printf %s "$txt") || die

####
# MAN PAGE MARKDOWN SOURCE
#  - Place a Markdown-formatted version of the man page for this script
#    inside the here-document below.
#    The document must be formatted to look good in all 3 viewing scenarios:
#     - as a man page, after conversion to ROFF with marked-man
#     - as plain text (raw Markdown source)
#     - as HTML (rendered Markdown)
#  Markdown formatting tips:
#   - GENERAL
#     To support plain-text rendering in the terminal, limit all lines to 80 chars.,
#     and, for similar rendering as HTML, *end every line with 2 trailing spaces*.
#   - HEADINGS
#     - For better plain-text rendering, leave an empty line after a heading
#       marked-man will remove it from the ROFF version.
#     - The first heading must be a level-1 heading containing the utility
#       name and very brief description; append the manual-section number 
#       directly to the CLI name; e.g.:
#         # foo(1) - does bar
#     - The 2nd, level-2 heading must be '## SYNOPSIS' and the chapter's body
#       must render reasonably as plain text, because it is printed to stdout
#       when  `-h`, `--help` is specified:
#         Use 4-space indentation without markup for both the syntax line and the
#         block of brief option descriptions; represent option-arguments and operands
#         in angle brackets; e.g., '<foo>'
#     - All other headings should be level-2 headings in ALL-CAPS.
#   - TEXT
#      - Use NO indentation for regular chapter text; if you do, it will 
#        be indented further than list items.
#      - Use 4-space indentation, as usual, for code blocks.
#      - Markup character-styling markup translates to ROFF rendering as follows:
#         `...` and **...** render as bolded (red) text
#         _..._ and *...* render as word-individually underlined text
#   - LISTS
#      - Indent list items by 2 spaces for better plain-text viewing, but note
#        that the ROFF generated by marked-man still renders them unindented.
#      - End every list item (bullet point) itself with 2 trailing spaces too so
#        that it renders on its own line.
#      - Avoid associating more than 1 paragraph with a list item, if possible,
#        because it requires the following trick, which hampers plain-text readability:
#        Use '&nbsp;<space><space>' in lieu of an empty line.
####
: <<'EOF_MAN_PAGE'
# nws(1) - normalize whitespace

## SYNOPSIS

Normalizes whitespace in one of several modes.

    nws [-m <mode>] [<text>...]

`<mode>` values (treatment of newlines in multi-line input):

    mp   (default) multi-paragraph: fold multiple blank lines into one
    fp   flattened multi-paragraph: normalize each paragraph to single line
    sp   single-paragraph: remove all blank lines.
    sl   single-line: normalize to single output line

Alternatively, specify mode values directly as options; e.g., `--sp` in lieu  
of `-m sp`

Standard options: `--help`, `--man`, `--version`, `--home`

## DESCRIPTION

`nws` (*n*ormalize *w*hite*s*pace) performs whitespace normalization,  
offering several modes.

Input is provided via one or more operands or, in their absence, via stdin.  
To disambiguate operands from options, precede operands with `--` as a  
separate argument.

Specifying a mode with option `-m` applies only to *multi-line* input;  
all modes behave identically with respect to normalizing a given single  
line, namely:  
Any run of any mix of spaces and tabs is replaced with a single space  
each, except leading and trailing runs, which are discarded.

## OPTIONS

  * `-m <mode>` or `--mode <mode>`  
    where `<mode>` is one of:

    * `mp`, `multi-para` (default)  
      Runs of blank (all-whitespace or empty) lines are replaced with 1 empty  
      line each, resulting in paragraph-internal newlines getting preserved,  
      with blank lines at the beginning, between paragraphs, and at the end  
      getting normalized to a single empty line each.  

    * `fp`, `flat-para`  
      Like mode `mp`, except that paragraph-internal newlines are replaced  
      with a single space each, resulting in each paragraph becoming a  
      single line, with 1 empty line between paragraphs.  

    * `sp`, `single-para`  
      Runs of blank (all-whitespace or empty) lines are discarded, resulting  
      in a single paragraph of non-blank lines.

    * `sl`, `single-line`  
      Normalization includes newlines too, so that any run of any mix of  
      spaces, tabs, and newlines is replaced with a single space each,  
      resulting in a single, long output line.

You may specify mode values as options directly; e.g., `--fp` or `--flat-para`  
in lieu of  `-m fp` or `--mode fp` or `--mode flat-para`.

## STANDARD OPTIONS

All standard options provide information only.

 * `-h, --help`  
   Prints the contents of the synopsis chapter to stdout for quick reference.

 * `--man`  
   Displays this manual page, which is a helpful alternative to using `man`,  
   if the manual page isn't installed.

 * `--version`  
   Prints version information.
  
 * `--home`  
   Opens this utility's home page in the system's default web browser.

## LICENSE

For license information, bug reports, and more, visit this utility's home page  
by running `nws --home`

## EXAMPLES
    
The examples use ANSI C-quoted input strings (`$'...'`) for brevity, which  
are supported in Bash, Ksh, and Zsh.  
Empty output lines are represented by `~`.

    # Single-line input - no mode needed.
    $ nws $'  one \t\t two  three   '
    one two three

    # Default: multi-paragraph mode (`-m mp` or `--mode multi-para`)
    $ nws <<<$'\n\n  one\n two \n\n\n  three\n\n'
    ~
    one
    two
    ~
    three
    ~

    # Single-paragraph mode; `-m sp` is the short equivalent of
    # `--mode single-para`.
    $ nws -m sp <<<$'\n\n  one\n two \n\n\n  three\n\n'
    one
    two
    three

    # Flattened-paragraph mode; note use of shorcut option `--fp` for `-m fp`.
    nws --fp <<<$'\n\n  one\n two \n\n\n  three\n\n'
    ~
    one two
    ~
    three
    ~

    # Single-line mode
    $ nws --sl <<<$'  one two\n  three '
    one two three

EOF_MAN_PAGE
